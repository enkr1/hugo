{{/* Reading Progress Bar */}}
<div class="reading-progress" id="reading-progress"></div>

{{/* Mobile Bottom Navigation */}}
<nav class="mobile-nav" id="mobile-nav">
    {{ $currentPage := . }}
    {{ range .Site.Menus.main }}
    {{ $active := or (eq $currentPage.RelPermalink .URL) (or ($currentPage.HasMenuCurrent "main" .) ($currentPage.IsMenuCurrent "main" .)) }}
    <a href="{{ .URL }}" class="mobile-nav__item{{ if $active }} active{{ end }}"{{ if eq .Params.newTab true }} target="_blank"{{ end }}>
        {{ $icon := default .Pre .Params.Icon }}
        {{ with $icon }}
            {{ partial "helper/icon" . }}
        {{ end }}
        <span>{{ .Name }}</span>
    </a>
    {{ end }}
    {{/* Search button */}}
    <button class="mobile-nav__item" data-search-trigger aria-label="Search">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="11" cy="11" r="8"></circle>
            <path d="m21 21-4.3-4.3"></path>
        </svg>
        <span>Search</span>
    </button>
</nav>

{{/* Scroll to Top Button */}}
<button class="scroll-to-top" id="scroll-to-top" aria-label="Scroll to top">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
</button>

<script>
(function() {
    // Reading Progress
    const progressBar = document.getElementById('reading-progress');

    // Scroll to Top
    const scrollBtn = document.getElementById('scroll-to-top');
    const scrollThreshold = 300;

    function updateProgress() {
        const scrollTop = window.scrollY;
        const docHeight = document.documentElement.scrollHeight - window.innerHeight;

        if (progressBar) {
            const progress = docHeight > 0 ? (scrollTop / docHeight) * 100 : 0;
            progressBar.style.width = progress + '%';
        }

        if (scrollBtn) {
            scrollBtn.classList.toggle('visible', scrollTop > scrollThreshold);
        }
    }

    // Throttle scroll event for performance
    let ticking = false;
    window.addEventListener('scroll', function() {
        if (!ticking) {
            window.requestAnimationFrame(function() {
                updateProgress();
                ticking = false;
            });
            ticking = true;
        }
    });

    // Scroll to top on click
    if (scrollBtn) {
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    }

    // Initial update
    updateProgress();
})();
</script>

{{/* Firestore View Count - only in production */}}
{{ if not hugo.IsServer }}
<script type="module">
import { doc, collection, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

// Wait for Firebase to initialize
function waitForFirestore(callback, maxAttempts = 20) {
    let attempts = 0;
    const check = () => {
        if (window.firestoreDb) {
            callback(window.firestoreDb);
        } else if (attempts < maxAttempts) {
            attempts++;
            setTimeout(check, 100);
        }
    };
    check();
}

async function getCount(db, docRef, increaseCount, title) {
    try {
        const d = await getDoc(docRef);
        let count = 0;

        if (!d.exists()) {
            if (increaseCount) {
                await setDoc(docRef, { count: 1 });
                count = 1;
                localStorage.setItem(title, 'true');
            }
        } else {
            count = d.data().count;
            if (increaseCount) {
                await setDoc(docRef, { count: count + 1 });
                count++;
                localStorage.setItem(title, 'true');
            }
        }
        return count;
    } catch (err) {
        console.error('[Firestore] Error:', err);
        return null;
    }
}

async function hashIP(ip) {
    const msgUint8 = new TextEncoder().encode(ip);
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

async function getVisitorIP() {
    try {
        const response = await fetch('https://ipwho.is/', { cache: 'no-store' });
        if (!response.ok) throw new Error('IP API failed');
        const data = await response.json();
        if (!data.success) throw new Error('IP API error');
        return {
            ip: data.ip,
            city: data.city,
            country: data.country,
            region: data.region,
            userAgent: navigator.userAgent
        };
    } catch {
        try {
            const fallback = await fetch('https://api64.ipify.org?format=json');
            const data = await fallback.json();
            return { ip: data.ip, city: 'Unknown', country: 'Unknown', region: 'Unknown', userAgent: navigator.userAgent };
        } catch {
            return null;
        }
    }
}

async function trackUniqueVisitor(db) {
    const visitorData = await getVisitorIP();
    if (!visitorData) return;

    const hashedIp = await hashIP(visitorData.ip);
    const ipDoc = doc(db, 'unique_visitors', hashedIp);
    const docSnapshot = await getDoc(ipDoc);

    if (!docSnapshot.exists()) {
        await setDoc(ipDoc, {
            ip: visitorData.ip,
            timestamp: new Date(),
            geolocation: `${visitorData.city}, ${visitorData.country}`,
            userAgent: navigator.userAgent
        });
    }
}

waitForFirestore(async (db) => {
    // Track unique visitors
    trackUniqueVisitor(db);

    // Get all view count elements
    const countElements = document.querySelectorAll('.firestore-visitors-count');
    if (!countElements.length) return;

    // Check if we're on a single article page (has exactly one count element with a title)
    const isSingleArticle = countElements.length === 1 && document.querySelector('article.main-article');

    if (isSingleArticle) {
        const el = countElements[0];
        const title = el.dataset.postTitle;
        if (!title) return;

        const docRef = doc(db, 'articles', title);
        const increaseCount = !localStorage.getItem(title);

        const count = await getCount(db, docRef, increaseCount, title);
        if (count !== null) el.textContent = count;
    } else {
        // List page - fetch all counts without incrementing
        const promises = [...countElements].map(async (el) => {
            const title = el.dataset.postTitle;
            if (!title) return;

            const docRef = doc(db, 'articles', title);
            const count = await getCount(db, docRef, false, title);
            if (count !== null) el.textContent = count;
        });
        await Promise.all(promises);
    }
});
</script>
{{ end }}
